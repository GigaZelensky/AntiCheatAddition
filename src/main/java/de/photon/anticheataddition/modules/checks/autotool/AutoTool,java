package de.photon.anticheataddition.modules.checks.autotool;

import de.photon.anticheataddition.modules.ViolationModule;
import de.photon.anticheataddition.user.User;
import de.photon.anticheataddition.user.data.TimeKey;
import de.photon.anticheataddition.util.mathematics.MathUtil;
import de.photon.anticheataddition.util.minecraft.ping.PingProvider;
import de.photon.anticheataddition.util.minecraft.tps.TPSProvider;
import de.photon.anticheataddition.util.violationlevels.Flag;
import de.photon.anticheataddition.util.violationlevels.ViolationLevelManagement;
import de.photon.anticheataddition.util.violationlevels.ViolationManagement;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.inventory.ItemStack;

public final class AutoTool extends ViolationModule implements Listener
{
    public static final AutoTool INSTANCE = new AutoTool();

    private final int cancelVl = loadInt(".cancel_vl", 50);
    private final int maxPing = loadInt(".max_ping", 400);
    private final boolean checkToolSwitch = loadBoolean(".check_tool_switch", true);
    private final boolean checkUnnaturalUsage = loadBoolean(".check_unnatural_usage", true);
    private final int toolSwitchInterval = loadInt(".tool_switch_interval", 50);

    private AutoTool()
    {
        super("AutoTool");
    }

    @EventHandler(ignoreCancelled = true)
    public void onBlockBreak(BlockBreakEvent event)
    {
        final var user = User.getUser(event.getPlayer());
        if (User.isUserInvalid(user, this) ||
            // Tps are high enough
            !TPSProvider.INSTANCE.atLeastTPS(19) ||
            // Prevent the detection of false positives
            PingProvider.INSTANCE.atMostMaxPing(user.getPlayer(), maxPing)) return;

        final Block block = event.getBlock();
        final Material blockMaterial = block.getType();
        final ItemStack heldItem = user.getPlayer().getInventory().getItemInHand();

        if (checkToolSwitch) {
            checkToolSwitchPattern(user, heldItem, blockMaterial);
        }

        if (checkUnnaturalUsage) {
            checkUnnaturalToolUsage(user, heldItem, blockMaterial, event);
        }
    }

    private void checkToolSwitchPattern(User user, ItemStack heldItem, Material blockMaterial)
    {
        // Check for rapid tool switching without apparent need
        if (user.getTimeMap().at(TimeKey.TOOL_SWITCH).recentlyUpdated(toolSwitchInterval) &&
            // Only flag if the current tool is not optimal for the block
            !isOptimalToolForBlock(heldItem, blockMaterial)) {
            getManagement().flag(Flag.of(user)
                                     .setAddedVl(25)
                                     .setCancelAction(cancelVl, () -> {}));
        }
    }

    private void checkUnnaturalToolUsage(User user, ItemStack heldItem, Material blockMaterial, BlockBreakEvent event)
    {
        // Detect impossible breaking speeds or tool mismatches
        if (!isOptimalToolForBlock(heldItem, blockMaterial)) {
            double breakTime = calculateExpectedBreakTime(heldItem, blockMaterial);
            double actualBreakTime = calculateActualBreakTime(user);

            if (actualBreakTime < breakTime * 0.5) {
                getManagement().flag(Flag.of(user)
                                         .setAddedVl(30)
                                         .setCancelAction(cancelVl, () -> event.setCancelled(true))
                                         .setDebug(() -> "AutoTool-Debug | Unnatural tool usage detected. Block: " + blockMaterial + 
                                                         ", Tool: " + (heldItem != null ? heldItem.getType() : "None") + 
                                                         ", Expected Break Time: " + breakTime + 
                                                         ", Actual Break Time: " + actualBreakTime));
            }
        }
    }

    private boolean isOptimalToolForBlock(ItemStack tool, Material blockMaterial)
    {
        if (tool == null) return false;

        return switch (blockMaterial) {
            case STONE, COBBLESTONE, MOSSY_COBBLESTONE, STONE_BRICKS -> tool.getType().name().contains("PICKAXE");
            case OAK_LOG, SPRUCE_LOG, BIRCH_LOG, JUNGLE_LOG, ACACIA_LOG, DARK_OAK_LOG -> tool.getType().name().contains("AXE");
            case DIRT, GRASS_BLOCK, SAND, GRAVEL -> tool.getType().name().contains("SHOVEL");
            default -> false;
        };
    }

    private double calculateExpectedBreakTime(ItemStack tool, Material blockMaterial)
    {
        // Placeholder implementation - would need more sophisticated logic in a real-world scenario
        if (tool == null) return Double.MAX_VALUE;

        return switch (blockMaterial) {
            case STONE, COBBLESTONE -> tool.getType().name().contains("PICKAXE") ? 1.5 : 7.5;
            case OAK_LOG -> tool.getType().name().contains("AXE") ? 3.0 : 9.0;
            case DIRT -> tool.getType().name().contains("SHOVEL") ? 0.75 : 3.75;
            default -> 3.0;
        };
    }

    private double calculateActualBreakTime(User user)
    {
        return user.getTimeMap().at(TimeKey.BLOCK_BREAK).passedTime() / 1000.0;
    }

    @Override
    protected ViolationManagement createViolationManagement()
    {
        return ViolationLevelManagement.builder(this)
                                       .loadThresholdsToManagement()
                                       .withDecay(120, 25)
                                       .build();
    }
}